

Playfair Cipher

    def create_playfair_square(phrase):
        """
        Generate the Playfair square for the given phrase.
        """
        # Replace 'J' with 'I' in the phrase, convert to uppercase, and append the alphabet
        key = phrase.replace('J', 'I').upper() + 'ABCDEFGHIKLMNOPQRSTUVWXYZ'
        key = "".join(dict.fromkeys(key))  # Remove duplicate letters while preserving order
        grid = [[key[i + j] for j in range(5)] for i in range(0, 25, 5)]
        return grid



    def find_location(grid, char):
        """
        Helper function to get the row and column of the given char.
        """
        for i in range(0, 5):
            for j in range(0, 5):
                if grid[i][j] == char:
                    return i, j


    def playfair_encrypt(message: str, key: str) -> str:
        """
        Encrypt a message using the Playfair cipher.
        """
        playfair_square = create_playfair_square(key)
        ciphertext = ''

        # Remove non-alphabetic characters
        message = "".join(filter(str.isalpha, message))

        # Handle repeating letters by inserting 'X' between them
        i = 0
        while i < len(message) - 1:
            if message[i] == message[i+1]:
                message = message[:i+1] + 'X' + message[i+1:]
            i += 1
        
        # Append 'Z' if the last block only contain a single character
        if len(message) % 2 == 1:
            message += 'Z'

        # For each digraphs, substitute the characters using the grid
        for i in range(0, len(message), 2):
            digraph = message[i:i+2]
            row1, col1 = find_location(playfair_square, digraph[0])
            row2, col2 = find_location(playfair_square, digraph[1])
            if row1 == row2:
                sub1 = playfair_square[row1][(col1 + 1) % 5]
                sub2 = playfair_square[row2][(col2 + 1 ) % 5]
            elif col1 == col2:
                sub1 = playfair_square[(row1 + 1) % 5][col1]
                sub2 = playfair_square[(row2 + 1) % 5][col2]
            else:
                sub1 = playfair_square[row1][col2]
                sub2 = playfair_square[row2][col1]
            
            ciphertext += sub1 + sub2

        return ciphertext


    def playfair_decrypt(ciphertext: str, key: str) -> str:
        """
        Decrypt a message using the Playfair cipher.
        """
        playfair_square = create_playfair_square(key)
        message = ''

        # For each digraphs, substitute the characters using the grid
        for i in range(0, len(ciphertext), 2):
            digraph = ciphertext[i:i+2]
            row1, col1 = find_location(playfair_square, digraph[0])
            row2, col2 = find_location(playfair_square, digraph[1])
            if row1 == row2:
                sub1 = playfair_square[row1][(col1 - 1) % 5]
                sub2 = playfair_square[row2][(col2 - 1 ) % 5]
            elif col1 == col2:
                sub1 = playfair_square[(row1 - 1) % 5][col1]
                sub2 = playfair_square[(row2 - 1) % 5][col2]
            else:
                sub1 = playfair_square[row1][col2]
                sub2 = playfair_square[row2][col1]
            
            message += sub1 + sub2

        # Remove the 'X' between two similar letters
        i = 0
        while i < len(message) - 2:
            if message[i] == message[i+2] and message[i+1] == 'X':
                message = message[:i+1] + message[i+2:]
            i += 1

        # Remove the last 'Z'
        if message[-1] == 'Z':
            message = message[:-1]

        return message

    keyword = 'BRSRHMCQEL'
    message = 'DIAMOND'

    encrypted = playfair_encrypt(message, keyword)
    print(encrypted)

    decrypted = playfair_decrypt("HBTIDBHKMO", keyword)
    print(decrypted)

    FKKAPOKV
    SMILCVMIRU

VigenÃ¨re Cipher

    def generate_key(msg, key):
        key = list(key)
        if len(msg) == len(key):
            return key
        else:
            for i in range(len(msg) - len(key)):
                key.append(key[i % len(key)])
        return "".join(key)

    def encrypt_vigenere(msg, key):
        encrypted_text = []
        key = generate_key(msg, key)
        for i in range(len(msg)):
            char = msg[i]
            if char.isupper():
                encrypted_char = chr((ord(char) + ord(key[i]) - 2 * ord('A')) % 26 + ord('A'))
            elif char.islower():
                encrypted_char = chr((ord(char) + ord(key[i]) - 2 * ord('a')) % 26 + ord('a'))
            else:
                encrypted_char = char
            encrypted_text.append(encrypted_char)
        return "".join(encrypted_text)

    def decrypt_vigenere(msg, key):
        decrypted_text = []
        key = generate_key(msg, key)
        for i in range(len(msg)):
            char = msg[i]
            if char.isupper():
                decrypted_char = chr((ord(char) - ord(key[i]) + 26) % 26 + ord('A'))
            elif char.islower():
                decrypted_char = chr((ord(char) - ord(key[i]) + 26) % 26 + ord('a'))
            else:
                decrypted_char = char
            decrypted_text.append(decrypted_char)
        return "".join(decrypted_text)

    text_to_encrypt = "CYBERSECURITY"
    key = "BEST"

    encrypted_text = encrypt_vigenere(text_to_encrypt, key)
    print(f"Encrypted Text: {encrypted_text}")

    decrypted_text = decrypt_vigenere(encrypted_text, key)
    print(f"Decrypted Text: {decrypted_text}")

    Encrypted Text: DCTXSWWVVVAMZ
    Decrypted Text: CYBERSECURITY
